//
// C++ Interface: select.h
//
// Copyright: See COPYING file that comes with this distribution
//
//
#ifndef __INCLUDE_SELECT_H
#define __INCLUDE_SELECT_H

#if __cplusplus < 201103L
#include <boost/shared_ptr.hpp>
#else
#include <memory>
#endif

#include <boost/date_time/posix_time/posix_time_types.hpp>

#include <iostream>
#include <string.h>
#include <libgen.h>

#include <mysql/mysql.h>
#include <mysql/errmsg.h>

using boost::posix_time::ptime;

#ifdef NDEBUG
#ifndef ASSERT_MSG
#define ASSERT_MSG(cond, msg) do { if (!(cond)) { std::cerr << " WARNING: " << msg << std::endl; assert(cond); }} while (false)
#endif
#ifndef LOG_MSG
#define LOG_MSG(msg) { std::cerr << " WARNING: " << msg << std::endl; } while (false)
#endif
#else
#ifndef ASSERT_MSG
#define ASSERT_MSG(cond, msg) do { if (!(cond)) { std::cerr << __FILE__ << ':' << __LINE__ << " WARNING: " << msg << std::endl; assert(cond); }} while (false)
#endif
#ifndef LOG_MSG
#define LOG_MSG(msg) do { std::cerr << __FILE__ << ':' << __LINE__ << " WARNING: " << msg << std::endl; } while (false)
#endif
#endif

#ifndef DBBINDERCONVERTTIME
#define DBBINDERCONVERTTIME
inline MYSQL_TIME dbbinderConvertTime(ptime v)
{
    MYSQL_TIME result;

    if (v.is_not_a_date_time())
    {
        memset(&result, 0, sizeof(MYSQL_TIME));
    }
    else
    {
        const boost::gregorian::date& d = v.date();
        result.year = d.year();
        result.month = d.month();
        result.day = d.day();

        const boost::posix_time::time_duration& t = v.time_of_day();
        result.hour = t.hours();
        result.minute = t.minutes();
        result.second = t.seconds();

        result.neg = false;
        result.time_type = MYSQL_TIMESTAMP_DATETIME;
    }
    return result;
}

inline ptime dbbinderConvertTime(MYSQL_TIME v)
{
    if (v.year && v.month && v.day)
        return ptime(boost::gregorian::date(v.year, v.month, v.day),
                     boost::posix_time::time_duration(v.hour, v.minute, v.second, v.second_part));
    return ptime();
}
#endif // DBBINDER_CONVERT_TIME_MYSQL_TIME

#ifndef MYSQLCHECKSTMTERR
#define MYSQLCHECKSTMTERR
inline void mysqlCheckStmtErr(MYSQL_STMT *_stmt, int _status)
{
    if (_status)
    {
        switch(_status)
        {
        case CR_COMMANDS_OUT_OF_SYNC:
            ASSERT_MSG(false, "Commands were executed in an improper order.");
            break;
        case CR_OUT_OF_MEMORY:
            ASSERT_MSG(false, "Out of memory.");
            break;
        case CR_SERVER_GONE_ERROR:
            ASSERT_MSG(false, "The MySQL server has gone away.");
            break;
        case CR_SERVER_LOST:
            ASSERT_MSG(false, "The m_connection to the server was lost during the query.");
            break;
        case CR_UNKNOWN_ERROR:
            ASSERT_MSG(false, "An unknown error occurred.");
            break;
        case CR_UNSUPPORTED_PARAM_TYPE:
            ASSERT_MSG(false, "The buffer type is MYSQL_TYPE_DATE, MYSQL_TYPE_TIME, MYSQL_TYPE_DATETIME, or MYSQL_TYPE_TIMESTAMP, but the data type is not DATE, TIME, DATETIME, or TIMESTAMP.");
            break;
        }

        ASSERT_MSG(false, "MySQL: " << mysql_stmt_error(_stmt));
        exit(-1);
    }
}
#endif // MYSQLCHECKSTMTERR

/**
 * @class select_blob
 * @brief File autogenerated by dbbinder++
 * This class encapsulates:
 *
 *
 * select
    `id`,
    `comment`
from
    dbtest
 *
 *
 *
 */
class select_blob
{
public:
    select_blob(MYSQL* _conn);
    ~select_blob();
private:
    MYSQL*	m_conn;

public:

private:
    static const char* const s_selectSQL;
    static const int         s_selectSQL_len;
    static const int         s_selectFieldCount;
    static const int         s_selectParamCount;

    MYSQL_STMT* m_selectStmt;
    bool                        m_selectIsActive;

    bool fetchRow();

    MYSQL_BIND inBuffer[0];

    MYSQL_BIND selOutBuffer[2];

    my_bool	m_idIsNull;
    long unsigned m_idLength;
    int m_buffid;

    my_bool	m_commentIsNull;
    long unsigned m_commentLength;

public:
    void open(  );
    void close();

    class _row_type
    {
        friend class select_blob;

    private:
        _row_type():
            m_id(0),m_comment()
        {}

        _row_type(select_blob *_parent)
        {
            m_id = _parent->m_buffid;
            m_isNullid = _parent->m_idIsNull;;
            if (!_parent->m_commentIsNull)
            {
                m_comment = std::make_shared< std::vector<char> >();
                m_comment->resize(_parent->m_commentLength);

                _parent->selOutBuffer[1].buffer_length = _parent->m_commentLength;
                _parent->selOutBuffer[1].buffer = m_comment->data();

                if(_parent->m_commentLength)
                    mysqlCheckStmtErr(_parent->m_selectStmt, mysql_stmt_fetch_column(_parent->m_selectStmt, &(_parent->selOutBuffer[1]), 1, 0));

                _parent->selOutBuffer[1].buffer_length = 0;
                _parent->selOutBuffer[1].buffer = nullptr;
            }
            m_isNullcomment = _parent->m_commentIsNull;;

        }

        int m_id;
        bool m_isNullid;
        std::shared_ptr< std::vector<char> > m_comment;
        bool m_isNullcomment;

    public:

        /**
        *
        * @return int
        */
        int getid() const
        {
            return m_id;
        }

        bool isNullid() const
        {
            return m_isNullid;
        }

        /**
        *
        * @return std::shared_ptr< std::vector<char> >
        */
        std::shared_ptr< std::vector<char> > getcomment() const
        {
            return m_comment;
        }

        bool isNullcomment() const
        {
            return m_isNullcomment;
        }

    };
#if __cplusplus < 201103L
    typedef boost::shared_ptr<_row_type> row;
#else
    typedef std::shared_ptr<_row_type> row;
#endif

    class iterator
    {
        friend class select_blob;

    public:
        iterator(select_blob* _parent):
            m_parent( _parent )
        {}

        select_blob *m_parent;

    public:
        const row& operator*() const
        {
            ASSERT_MSG( m_parent, "Called operator* without parent/after end." );
            return m_parent->m_currentRow;
        }

        const row& operator->() const
        {
            ASSERT_MSG( m_parent, "Called operator-> without parent/after end." );
            return m_parent->m_currentRow;
        }

        void operator++()
        {
            ASSERT_MSG( m_parent, "Called operator++ without parent/after end." );
            if ( !m_parent->fetchRow() )
                m_parent = 0;
        }

        void operator++(int count)
        {
            while(count-- > 0)
            {
                operator++();
            }
        }

        bool operator==(const iterator& _other) const
        {
            return m_parent == _other.m_parent;
        }

        bool operator!=(const iterator& _other) const
        {
            return m_parent != _other.m_parent;
        }

        typedef iterator iterator_category;
        typedef row value_type;
        typedef bool difference_type;
        typedef _row_type* pointer;
        typedef row reference;
    };
    typedef iterator const_iterator;

    iterator& begin();
    iterator& end()
    {
        return s_endIterator;
    }
    bool empty()
    {
        return begin() == end();
    }

private:
    row         m_currentRow;
    iterator    *m_iterator;
    static iterator	s_endIterator;

};

#undef ASSERT_MSG
#undef LOG_MSG

#endif
